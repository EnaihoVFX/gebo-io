// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract VideoToken is ERC1155, Ownable {
    using Counters for Counters.Counter;
    
    Counters.Counter private _tokenIds;
    
    struct Video {
        uint256 tokenId;
        address creator;
        string ipfsHash;
        uint256 nftPrice;
        uint256 coinPrice;
        uint256 totalSupply;
        uint256 stakedAmount;
        uint256 totalRevenue;
        bool exists;
    }
    
    struct Stake {
        uint256 amount;
        uint256 timestamp;
        uint256 rewards;
    }
    
    mapping(uint256 => Video) public videos;
    mapping(uint256 => mapping(address => Stake)) public stakes;
    mapping(uint256 => address) public nftOwners;
    
    uint256 public constant REWARD_RATE = 1250; // 12.5% APY (1250 basis points)
    uint256 public constant REVENUE_SHARE = 2000; // 20% (2000 basis points)
    
    event VideoCreated(uint256 indexed tokenId, address indexed creator, string ipfsHash);
    event TokensStaked(uint256 indexed tokenId, address indexed staker, uint256 amount);
    event NFTPurchased(uint256 indexed tokenId, address indexed buyer, uint256 price);
    event RewardsClaimed(uint256 indexed tokenId, address indexed staker, uint256 amount);
    event RevenueDistributed(uint256 indexed tokenId, uint256 amount);
    
    constructor() ERC1155("") Ownable(msg.sender) {}
    
    function createVideo(
        string memory ipfsHash,
        uint256 nftPrice,
        uint256 coinPrice,
        uint256 totalSupply
    ) external returns (uint256) {
        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();
        
        videos[newTokenId] = Video({
            tokenId: newTokenId,
            creator: msg.sender,
            ipfsHash: ipfsHash,
            nftPrice: nftPrice,
            coinPrice: coinPrice,
            totalSupply: totalSupply,
            stakedAmount: 0,
            totalRevenue: 0,
            exists: true
        });
        
        // Mint initial supply to creator
        _mint(msg.sender, newTokenId, totalSupply, "");
        
        emit VideoCreated(newTokenId, msg.sender, ipfsHash);
        return newTokenId;
    }
    
    function stakeTokens(uint256 tokenId, uint256 amount) external payable {
        require(videos[tokenId].exists, "Video does not exist");
        require(amount > 0, "Amount must be greater than 0");
        require(msg.value >= amount * videos[tokenId].coinPrice, "Insufficient payment");
        
        // Transfer tokens from staker to contract
        _safeTransferFrom(msg.sender, address(this), tokenId, amount, "");
        
        // Update stake
        stakes[tokenId][msg.sender].amount += amount;
        stakes[tokenId][msg.sender].timestamp = block.timestamp;
        
        // Update video stats
        videos[tokenId].stakedAmount += amount;
        
        emit TokensStaked(tokenId, msg.sender, amount);
    }
    
    function purchaseNFT(uint256 tokenId) external payable {
        require(videos[tokenId].exists, "Video does not exist");
        require(nftOwners[tokenId] == address(0), "NFT already sold");
        require(msg.value >= videos[tokenId].nftPrice, "Insufficient payment");
        
        nftOwners[tokenId] = msg.sender;
        
        // Transfer payment to creator
        payable(videos[tokenId].creator).transfer(msg.value);
        
        emit NFTPurchased(tokenId, msg.sender, msg.value);
    }
    
    function claimRewards(uint256 tokenId) external {
        require(stakes[tokenId][msg.sender].amount > 0, "No stakes found");
        
        uint256 stakedAmount = stakes[tokenId][msg.sender].amount;
        uint256 stakedTime = block.timestamp - stakes[tokenId][msg.sender].timestamp;
        uint256 rewards = (stakedAmount * REWARD_RATE * stakedTime) / (365 days * 10000);
        
        require(rewards > 0, "No rewards to claim");
        
        // Reset timestamp
        stakes[tokenId][msg.sender].timestamp = block.timestamp;
        stakes[tokenId][msg.sender].rewards += rewards;
        
        // Transfer rewards to staker
        payable(msg.sender).transfer(rewards);
        
        emit RewardsClaimed(tokenId, msg.sender, rewards);
    }
    
    function distributeRevenue(uint256 tokenId) external payable {
        require(videos[tokenId].exists, "Video does not exist");
        require(msg.value > 0, "No revenue to distribute");
        
        videos[tokenId].totalRevenue += msg.value;
        
        // Distribute to NFT owner (20%)
        if (nftOwners[tokenId] != address(0)) {
            uint256 nftShare = (msg.value * REVENUE_SHARE) / 10000;
            payable(nftOwners[tokenId]).transfer(nftShare);
        }
        
        // Distribute to creator (80%)
        uint256 creatorShare = msg.value - ((msg.value * REVENUE_SHARE) / 10000);
        payable(videos[tokenId].creator).transfer(creatorShare);
        
        emit RevenueDistributed(tokenId, msg.value);
    }
    
    function getStakeInfo(uint256 tokenId, address staker) external view returns (Stake memory) {
        return stakes[tokenId][staker];
    }
    
    function getVideoInfo(uint256 tokenId) external view returns (Video memory) {
        return videos[tokenId];
    }
    
    function getNFTOwner(uint256 tokenId) external view returns (address) {
        return nftOwners[tokenId];
    }
    
    function calculateRewards(uint256 tokenId, address staker) external view returns (uint256) {
        if (stakes[tokenId][staker].amount == 0) return 0;
        
        uint256 stakedTime = block.timestamp - stakes[tokenId][staker].timestamp;
        return (stakes[tokenId][staker].amount * REWARD_RATE * stakedTime) / (365 days * 10000);
    }
    
    // Override URI function for metadata
    function uri(uint256 tokenId) public view virtual override returns (string memory) {
        return string(abi.encodePacked("ipfs://", videos[tokenId].ipfsHash));
    }
} 